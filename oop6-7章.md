# oop6-7章

# 类和对象

### ADT

数学模型, 操作集合. (两有)

具体, 现实, 任意无穷(三五)

行为->多个操作->成员函数

数据->数据成员

### this指针

永远指向当前对象

### 类的定义

定义顺序随意

通常放入头文件

可以使用前置声明

### 类的构成

1. 数据成员(成员数据)
2. 成员函数(函数成员)

> [!caution]
>
> 防止递归定义->包含警戒
>
> 包含警戒->降低文件依赖性

> [!note]
>
> #pragma once
>
> 1.节省编译时间，多余的#include会迫使编译器展开更多文件，处理更多输入
> 2.节省不必要的重新编译时间。#include使代码因为头文件中无关的改动而被重新编译多次

#### 数据成员

1. 普通类型（指针、数组、引用等)

2. enum类型、 const 类型、static 
3.  struct 和class 不能递归定义，但可用指针
   成员函数

> [!tip]
>
> 对静态数据成员，如果是整型或枚举类型且被声明为const，那么可用常量表达式在类体内直接初始化

### 对象访问

#### 对象的访问-调用函数与发送消息

1. 直接向对象发送消息
2. 向指针指向的对象发送消息
3. 向引用对象发送消息

面向对象中更强调发送消息，接收对象及其相应行为是**不确定的**，也可能**不是同步**的。

### 对象占用存储空间

与非静态数据成员的个数、类型有关
与成员**函数的个数无关**
与静态数据成员的多少、类型**无关**
与访问控制无关
一定非0
与是否含有**虚函数**有关
与编译时字节对齐方式设置有关

#### 结构成员对齐的原因

1. 平台原因
2. 效率原因：正是由于只能在特定的地址处读取数据，所以在访问一些数据时，对于访问未对齐的内存，处理器需要进行两次访问；而对于对齐的内存，只需要访问一次就可以。其实这是一种以空间换时间的做法，但这种做法是值得的

#### 结构成员对齐的规则

1. 第一个成员在结构体变量偏移量为0的地址处，也就是第一个成员必须从头开始；
2. 其他成员变量要对齐到某个数字(对齐数)的整数倍的地址处。对齐数为编译器默认的对齐数与该成员大小中的较小值。只能修改为1,2,4,8,16.
3. 结构体总大小为最大对齐数的整数倍，每个成员变量都有自己的对齐数;
4. 如果嵌套结构体，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数(包含嵌套结构体的对齐数)的整数倍。

# 成员函数

### this pointer

this的作用域和生存期是在**非静态**成员函数的{ } 内
this指针永远指向当前对象 

是一个关键字，也是一个保留字；
是非静态成员函数隐含的第一个形参；
其类型相当于：  T * const this

### 外联实现

在类体外定义的成员函数具有外部链接性，因此，通常将类体外定义的**成员函数**放置在**源文件**中，而将**类定义**放置在头文件中

#### 分文件放置的好处是：

   1.类的实现文件通常较大，分开便于阅读、管理和维护；
   2.程序开发者可以只提供类的声明，而不用公开类成员函数的实现；
   3.将类定义放在头文件中，以后使用不必再定义，只须一条包含命令即可实现代码重用；
   4.便于团队分工合作开发

### 内联实现

直接在里面写或者使用inline.

#### 内联的作用:

建议编译器在**调用处**直接**展开函数**代码,
编译器拥有对任何未标记为inline的函数使用内联替换的自由，和对任何标记为inline的函数生成函数调用的自由。



#### inline关键字

内联函数的定义必须在访问它的**编译单元中可达**
在程序中可有**多于一次定义**，只要每个定义都出现在**不同编译单元**中且所有定义等同即可。例如，内联函数可定义于被多个源文件所 #include 的头文件中。
对于函数的意义已经变为“inline关键字：

n内联函数的定义必须在访问它的编译单元中可达

n在程序中可有多于一次定义，只要每个定义都出现在不同编译单元中且所有定义等同即可。例如，内联函数可定义于被多个源文件所 #include 的头文件中。

n对于函数的意义已经变为“容许多次定义”而不是“优先内联””而不是“优先内联”

### **封装与信息隐蔽**

**封装**： 将事物的特征和相关信息，通过打包的过程，包装成一个整体。

对事物的内部：沟通不受影响

对事物的外部：只能通过事物公开的特征进行沟通，不必了解事物的细节

C++中封装的实现**手段**---- class

**信息隐蔽**：在封装的过程中，使事物的部分信息对外部不可见，只公开部分必要信息。

C++中信息隐蔽的实现**手段**---- 访问控制

> [!note]
>
> 面向对象的基石，抽象是前提，封装与信息隐蔽是关键
>
> 封装的作用一：增加**内聚性**，进而提高可复用性和可维护性
> 封装的作用二：实现信息**隐藏**，信息隐藏是目的，封装是达到目的的技术手段
>
> 信息隐藏的作用一：降低**耦合性**，进而提高可复用性和可维护性
>     公开的属性或方法越多，修改时涉及的面也就越大，变更引起的风险扩散也就越大，信息隐藏可以减少公开的属性和方法，从而降低耦合性
> 信息隐藏的作用二：对数据存取方式加以约束，保持数据的**完整性**(**安全性有效性**) 
>    外部不能直接访问、只能通过公开方法间接访问隐藏的数据，可以方便地加入控制或校验，避免对数据的不合理操作，如人的年龄、圆的半径等，以及只读数据
> 信息隐藏的作用三：隐藏了实现细节，保持接口不变，则**实现的变化不影响外部**
>
>    只要接口不变，那么函数实现、数据组织、数据表示等发生变化，都不影响外部或影响较小，隔离变化，方便修改，利于维护和复用

# 行为函数

常对象只能访问常函数, 即使没改变成员变量的普通函数也不能访问.

> [!caution]
>
> 普通成员函数的this指针类型：                T  * const this
>     常成员函数的this指针类型：    const  T  * const this

# 实例变(常)量和实例方法

实例变(常)量: 每个对象独立拥有的数据成员
实例方法: 访问实例变(常)量的成员函数

# 类变(常)量和类方法

##### 类变量类变量：类具有的属性或应由类中所有对象共享的属性

C++中用**静态数据成员**表示
类变(常)量的内存位置
类变(常)量的初始化

##### 类方法：类属的行为表示

C++中用**静态成员函数表**示
不能直接访问任何非静态成员（数据成员和函数成员）
没有隐含的this指针, **也不能**带const修饰
常用**类名**作限定（最好不用对象名）
好：     ClassName::OneStaticFunction( );
不好：  objName.OneStaticFunction( );