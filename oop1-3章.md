1-3章基础知识

# 编程泛型(10个)

面向+**对象, 方面, 表格**+编程

**过程+命令+函数**+编程

**流程+消息**+驱动编程

**泛型+结构化**+编程

##### 编程泛型和C++语言

一种编程范型可以被多种语言支持, 一种语言也可以支持多种编程范型.

##### 集成开发环境(记住顺序) :

集成代码 编辑、编译、运行、调试、测试、发布等

## C++项目(工程）的组成: 

实现文件cpp, 头文件hpp, h

库文件, 可执行文件(dll, lib, exe), 资源文件(rc, res)

数据文件(XML, dat), 其他...

编译为: exe, dll, lib

# 预处理

处理源代码中的带有**#**号的语句，生成编译程序可处理的文本文件；

# 编译过程：

对每个预处理后源程序，编译并生成相应的二进制目标文件(object文件)。此过程中，仅要求编译器能够**识别每个标识符，知道其各自的类型、含义**，但不要求知道存放位置.

# 链接过程：

对在整个程序范围内，确定各标志符所代表的**地址**，如变量、函数入口(找到main函数)，生成可执行文件。此过程中，要求编译器能够确定每个标识符所对应的含义或地址。

> [!NOTE]
>
> 1. C++的编译是以实现文件(.cpp文件)为**基本编译单位**的；
> 2. 预编译、编译和链接过程，有时我们**统称编译过程**；
> 3. 各阶段均无错误，才能生成可执行文件；
> 4. 即使生成了可执行文件，不代表程序就正确；
> 5. 让编译过程通过，是相对简单的；真正困难的是调试逻辑错误

# 入口函数:

C/C++普通可执行程序(exe)的起始函数
返回值：int（只有早期的部分编译器支持void main()）
参数部分：无 或   (int argc,char* argv[ ])

# 前置声明:

前置声明：告诉编译器，一个标识符所代表的类型、含义等, 但不必告知其具体位置

# 多文件/头文件使用

从各自的c/cpp文件出发，将其向外部公开的**变量、函数、类/结构体**等，放入对应的头文件。

头文件中可放**声明**，以及**类定义(唯一的定义)**，但不应放**变量定义**和**函数定义**

说白了: 全局变量和全局函数的声明放在头文件中，将实现放在实现文件中

![image-20240605171458834](C:\Users\10164\AppData\Roaming\Typora\typora-user-images\image-20240605171458834.png)

# make工具

make工具说明(例): GNU make, C make, Q make, Ninja

# ADT

一个ADT：一个数学模型+可施加其上的操作集合。
（类型名称，**数据集**，数据间的**关系**，**操作**集）

# C++中的类型

![image-20240605172227020](C:\Users\10164\AppData\Roaming\Typora\typora-user-images\image-20240605172227020.png)

### 内置类型及其大小



### typedef

typedef可以用来定义已有类型的同义词，可以出现在程序中类型名可出现的任何位置
定义**类型**格式：typedef <已知类型>  <新类型>
定义**函数类型**格式： typedef ReturnType (*新类型)(参数列表);

> [!WARNING]
>
> 别忘了新类型要加 '*' 号!

typedef本质上**没有增加新类型**

> [!NOTE]
>
> 使用typedef不能直接重命名函数，但可以通过typedef定义函数指针类型，从而实现类似的效果。例如，假设有一个函数 `int add(int a, int b)`，可以通过typedef来定义一个新的类型来代表这个函数指针，然后使用这个新类型来声明函数指针变量，从而达到类似重命名函数的效果。

```cpp
#include <iostream>
using namespace std;

int add(int a, int  b)
{
	return a + b;
}
int sub(int a, int  b)
{
	return b - a;
}

typedef int(*hard)(int, int);// 使用typedef定义函数指针类型

int main()
{
	hard ptr = add;
	hard ptr2 = sub;
	cout << ptr(2, 3) << endl;  // 调用函数指针变量来调用原始函数
	cout << ptr2(2, 3) << endl;  // 调用函数指针变量来调用原始函数
	return 0;
}
```

# 枚举

> 如果一个变量只有几种可能的值，可以定义为枚举类型。所谓枚举就是指将变量的值一一列举出来，变量的值只能在列举出来的值的范围内。
> 例如，文件打开的状态可能会有三种：输入、输出和追加
> enum open_modes {input, output, append};

### C++98： enum 枚举类型名 {枚举值列表 };

```cpp
#include <stdio.h>

// 定义枚举类型 Weekday
enum Weekday {
    Monday,
    Tuesday,
    Wednesday,
    Thursday,
    Friday,
    Saturday,
    Sunday
};

int main() {
    // 声明 Weekday 类型的变量
    enum Weekday today;

    // 赋值
    today = Tuesday;

    // 输出当前星期几
    printf("Today is: %d\n", today);

    return 0;
}
```

枚举值必须是整数
第一个枚举值，缺省为0
后一个枚举值，若没有指定，则为前一个枚举值+1
内部就是int
int与枚举量可随意转换(98!)，不安全
同名枚举值的问题
      enum  Dir { LEFT,RIGHT };
      enum  State { RIGHT,FAILED };            RIGHT==0 还是 RIGHT==1 ？

### C++11： enum class 枚举类名 { 枚举值列表 };

> [!CAUTION]
>
> enum class 提供了更强的类型检查和作用域控制。使用enum class定义的枚举值被视为该枚举类型的成员，并且它们的作用域受限于枚举类的作用域。

```cpp
#include <iostream>
using namespace std;
enum class Day
{
	Monday=1,
	Tuesday,
	Wednesday,
	Thursday,
	Friday,
	Saturday,
	Sunday
};

int main()
{
	Day day;
	day = Day::Monday;
	cout << static_cast<float>(day) << endl;
}
```



1. 枚举值可以指定类型、指定数值
2. 枚举值不再允许与int随意转换、比较
3. 使用时必须指明scope(即枚举类名, 不会引起命名冲突)

# 声明和定义

### 声明

解释说明一个编译单元中一个名字的含义和属性。

```cpp
extern int a; 			// 声明外部整型变量a
extern const int c; 		// 声明外部整型常量c
int f(int); 			// 声明函数f
struct S; 			// 声明结构S
typedef int Int; 		// 声明类型 Int
extern X anotherX; 	// 声明外部变量anotherX
using N::d; 			// 声明名字d
```

### 定义

一个声明同时也是一个定义，当：

确定的函数体、确定的类内容、有具体值,  确定存储空间、确定别名等时

## 常见的声明和定义

![image-20240605194754956](C:\Users\10164\AppData\Roaming\Typora\typora-user-images\image-20240605194754956.png)

### 使用原则:

#### **就近原则(**现使用，现定义)

#### **先声明后使用原则**

#### **单一定义规则**:   

在一个编译单元中，同一个标识符（如变量、函数、类名等）只能被定义一次；但声明可以多次。

结论：
头文件中可放声明，以及类定义，但不应放**变量定义**和**函数定义**
函数定义及变量定义，只能在cpp文件中定义一次

# 变量的存储空间(!=作用域!)

在C++中，一个程序占用的内存区一般分为以下几部分
     1.**全局、静态变量数据区(也叫全局变量数据区, 静态变量数据区!!)**：存储全局变量及静态变量（包括全局静态变量和局部静态变量），**分配该区时内存全部清零**
     2.**常量数据区**：存储程序中的常量字符串等
     3.**代码区**：存储程序的代码，即程序中各个函数的代码块
     4.**栈区**：存储局部变量，如函数中的变量等；由系统自动分配，分配栈区时不处理内存，**即变量取随机值**
     5.**堆区**：存储动态产生的数据，由程序员动态分配和回收，分配堆区时不处理内存

# 作用域(!=存储空间)

> [!caution]
>
> 全局static类型为文件作用域!
>
> 全局的静态变量确实属于文件作用域，而不是全局作用域。这是因为在C++中，使用关键字`static`在全局作用域中声明变量会使其具有文件作用域。
>
> 全局作用域意味着变量在整个程序中都是可见的，而文件作用域意味着变量在整个源文件中都是可见的。使用`static`关键字在全局作用域中声明变量，将使其作用域**限制**在当前源文件中，而不是整个程序。

> [!note]
>
> const不会改变原来的作用域

![image-20240605195431074](C:\Users\10164\AppData\Roaming\Typora\typora-user-images\image-20240605195431074.png)

### 文件作用域和全局作用域

在 C 和 C++ 中，有不同的作用域来描述变量、函数和其他标识符的可见性和访问范围。主要有文件作用域（也称为**静态作用域**）和全局作用域。

1. **文件作用域：**
   
   - **定义：** 文件作用域是指在整个源文件中可见的作用域范围。
   - **范围：** 文件作用域适用于在文件的任何地方声明的标识符，如全局变量、静态变量和函数。
   - **可见性：** 在同一源文件中的任何位置，都可以访问文件作用域中的标识符。
   - **生命周期：** 具有文件作用域的标识符在整个程序的运行期间都是有效的。
   - **示例：** 
     ```c
     // File1.c
     int globalVariable = 10; // 具有文件作用域的全局变量
     
     void myFunction() {
         // 函数定义
     }
     
     static int staticVariable = 20; // 具有文件作用域的静态变量
     
     // File2.c
     // 在这里也能够访问 globalVariable 和 myFunction()
     ```

2. **全局作用域：**
   
   - **定义：** 全局作用域是指在整个程序中（包括多个源文件）都可见的作用域范围。
   
   - **范围：** 全局作用域适用于在任何源文件中声明的标识符，如全局变量和函数。
   
   - **可见性：** 在整个程序中的任何位置，都可以访问全局作用域中的标识符。
   
   - **生命周期：** 具有全局作用域的标识符在程序启动时创建，在程序结束时销毁。
   
   - **示例：**
     
     ```c
     // File1.c
     int globalVariable = 10; // 具有全局作用域的全局变量
     
     void myFunction() {
         // 函数定义
     }
     
     // File2.c
     // 在这里也能够访问 globalVariable 和 myFunction()
     ```

总的来说，文件作用域是指在单个源文件中可见的范围，而全局作用域是指在整个程序中可见的范围。在多文件项目中，文件作用域的变量和函数可以在**其所在的源文件**中使用，而**全局**作用域的变量和函数则可以在**整个程序中的任何地方**使用。



自我尝试

```cpp
//cpp01
#include <iostream>
using namespace std;
extern int a;//extern keyword is used to declare a variable as an external variable.
int main()
{
	cout << a;
}
```

```cpp
//cpp02
int a = 10;
```



### **变量的作用域**

##### 局部变量的生存期和作用域

1. 局部变量是指在一个**块**中声明的、即在一对花括号中声明的变量，也称为自动变量
2. 局部变量的作用域是从它声明的位置开始，直到所在**块**的结束(块作用域)
3. 局部变量从所在块执行起存在，直到所在块执行结束时自动消失。每次执行到**包含**局部变量声明的语句块时，就**创建**一个**新的变量**。如果为局部变量指定了初始值，则每次创建该变量时都会重新初始化它，如果没有为局部变量指定初始值，则它的初始值是**不确定**的

##### 全局变量的生存期和作用域

1. 全局变量是指在所有**块和类外部**声明的变量

2. 全局变量的作用域从它声明的位置开始至**源文件结束**（文件作用域），即全局变量能够被位于其定义位置之后的本源文件中的所有函数共用

3. 全局变量从程序开始执行起存在，直到程序结束时消失。全局变量的初始化在**main()开始执行之前进行**，如果没有为全局变量指定初始值，在默认情况下初始化为**0**，并**转换**为该变量适用的类型

4. 全局变量允许用extern将其作用域**扩展**至其它源文件

##### 静态变量的生存期和作用域

1. 静态变量的作用域可以是文件作用域，也可以是块作用域、类作用域，因此静态变量可以是局部静态变量，也可以是全局静态变量

2. 静态变量从程序开始执行到声明它的语句起存在，直到程序结束时消失。如果没有为静态变量指定初始值，则它总是会自动初始化为0，并转换为该变量适用的类型

   ###### 全局静态变量与全局变量的区别

   ​    全局静态变量的作用域**局限**于所在源文件，**不允许用extern**将其作用域扩展至其它源文件
   
   # 包含警戒
   
   > [!NOte]
   >
   > #ifndef XXXX语句中的XXXX，不必须是大写字母或下划线. 为了区分宏定义和其他标识符，习惯性地将宏定义的标识符写成大写字母的形式，例如`#ifndef XXXX`中的`XXXX`。
   
   
   
   > [!CAUTION]
   >
   > #pragma once不能解决全部的问题.
   >
   > 如果在头文件写了函数的定义(这违法了原则), 就会导致重定义(报错为已有主体).
   
   ```h
   //h
   #pragma once
   #include<iostream>
   using namespace std;
   void Meow()
   {
   	cout<<"Mewo"<<endl;
   }
   ```
   
   ```cpp
   //cpp1
   #include"head.h"
   #include<iostream>
   using namespace std;
   void Meow()
   {
   	cout << "e";
   }
   ```
   
   ```cpp
   //main
   #include "head.h"
   int main()
   {
   	Meow();
   	return 0;
   }
   ```
   
   ![image-20240605210150039](C:\Users\10164\AppData\Roaming\Typora\typora-user-images\image-20240605210150039.png)
   
   # 解释性语言
   
   C++是一种编译型语言，不是解释型语言。在C++中，源代码被编译成机器码或者中间代码，并生成可执行文件。这个可执行文件在运行时直接由计算机执行，而不需要在运行时逐行解释执行。
   
   编译型语言的主要优势是其运行效率高，因为在运行之前源代码已经被编译成机器码，不需要在运行时解释代码。这使得C++适合于需要高性能的应用场景.
   
   > [!NOTE]
   >
   > 使用Make工具可以加快编译速度,提高软件开发效率。
   
   