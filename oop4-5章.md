面向对象4-5章基础知识

# chapter4-指针, 数组, 引用, 常量



# 指针

> [!note]
>
> Type * varName [= 地址表达式]; 
>
> 应当定义+初始化

### 指针初始化和赋值操作的约束

    1. 0，NULL或nullptr
        例：int *pi=0; 或 const int num = 0; int *pi=num;
    1. 精确的类型匹配的对象的地址
        例：double dval;   int *pi=0;   pi=&dval; //错误
    1. **同类型的某个对象后面的另一对象**
        例：int  a[2]={1,2}; int * p1=&a[0]; int * p2=++p1;
    1. 同类型的另一个**有效**指针
        例：int *pd;   int *pi=pd; //错误

### 指针运算

```cpp
int main()
{
	int a[3]{ 1,5,3 };
	int* ptr = a;
	cout << *(ptr + 1);
	return 0;
}
```

> [!tip]
>
>  p+n等价于  (T* ) (  (( char * ) p + sizeof(T) * n) )
>
> 取数组元素p[n] 就是  *（p+n）//c++primer

> [!caution]
>
> *(p+n) != *p+n 

# 数组

> [!TIP]
>
> int a[5] {1,2,3,4,5};  int* b=a; int* c=&a[0]; 

> [!warning]
>
> 小心越界!
>
> char e[5] = “hello”; //错误，字符串字面值结尾有\0

### 数组(复杂)

##### 多维数组格式：

  (C++98) Type varName[ constexp1 ][constexp2]… [={初值列表}];

  (C++11) Type varName[ constexp1 ][constexp2]… [ {初值列表} ];

##### 指针数组与数组指针

###### 指针数组：int *  array[3];

######  数组指针：int (*p)[3];

```cpp
int a[5] = { 1,4,6,4,1 };

int* p[5] = { &a[0],&a[1],&a[2],&a[3],&a[4] };
for (int i = 0; i != 5; ++i)
{
	cout << *p[i] << endl;
}cout << endl;

int(*ptr)[5] = &a; //声明一个指向数组的指针
for (int i = 0; i != 5; ++i)
{
	cout << (*ptr)[i] << endl;
}
```

###### **数组引用**void g( int (&ra) [3] )；

> [!tip]
>
> 这个函数声明 `void g(int (&ra)[3]);` 可以理解为定义了一个函数 `g`，它接受一个引用参数 `ra`，这个引用参数指向一个包含3个整数的数组。
>
> 让我们分解一下这个声明：
>
> - `int (&ra)[3]`: 这是函数 `g` 的参数声明。`&ra` 表示这是一个引用，而不是传值，所以在调用函数时不会进行数组的拷贝。`[3]` 表示这个引用指向的是一个大小为3的数组。
>
> 这样，函数 `g` 接受一个大小为3的整型数组的引用作为参数。这样定义函数参数为引用的好处是，函数内部可以直接操作原始数组，而不需要拷贝整个数组，从而节省了内存和时间。

for example:

```cpp

#include <iostream>
using namespace std;
//数组指针, 指针数组

int a[20]{ 1,1,2,3,5,8,13,21,3 };

void g(int(&RefArr)[20])
{
	for (int i = 0; i < 20; i++)
	{
		cout << RefArr[i] << " ";
	}cout << endl;
}

int main()
{
	g(a);
	return 0;
}
```

### 数组名字

1. C++数组名可用作到它第一个元素的指针 

```cpp
int   a[4] = { 1,2,3,4 };
int* pa = a;   int* pa = &a[0];
cout << p[3];
```

2. C++数组名字可以看作一个**指针常量**，其指向数组的第一个元素

3. 可以通过指针访问数组中的每个元素

   #####       一维数组的指针表示法：

   ​      例：int a[4]; 用a[i] or *(a+i) 访问数组元素，i取0 1 2 3

   ######       二维数组的指针表示法：        

   ###### ![image-20240605214527186](C:\Users\10164\AppData\Roaming\Typora\typora-user-images\image-20240605214527186.png)

# 引用

1. 类型必须严格匹配
2. 初始化

# 引用和指针

##### 引用和指针之间的共同点

​    1.都可以作为函数的参数和返回值
​    2.都是左值，可以放在赋值运算符左侧

##### 引用和指针之间的区别

​    1.引用通过别名直接访问，指针通过地址间接访问
​    2.引用在定义时必须初始化。可避免使用无效指针
​    3.引用在初始化后不可改变。指针可用于遍历数组元素
​    4.不存在空引用。当所指对象可能不存在时可用指针
​       int fun(int a) {  return a; }   int &r = fun(10); //错误

# #define优缺点

##### 缺点

宏定义只是进行简单的字符替换，没有类型安全检查
宏定义还会产生边际效应   
无法对宏定义的符号常量进行调试
宏定义的符号常量的作用域，**从定义点到整个程序的结束点**，容易与其它变量产生命名冲突

##### 优点

可用于条件编译，#define XXX  #ifdef  XXX   #endif
可用于字符及字符串，#，##，#@
编译器内置宏，能输出非常有用的调试信息

###### 条件编译

```cpp
//条件编译(例)
#define DEBUG
int main() 
{
	int  a = 100;
#ifdef DEBUG
	cout << DEBUG << endl;
	Do1();
#else
	Do2();
#endif
}
```

###### 宏使用

```cpp
void alg()
{
cout << __FILE__ << __LINE__ << __func__ << endl;
}

int main()
{
alg();
}

```

> [!warning]
>
> 只不过有了这个 #ifndef 的条件编译，所以能保证你的头文件只被引用一次，不过也许还是不会出岔子，但**若多个 c 文件包含这个头文件时还是会出错的**，因为宏名有效范围仅限于本c源文件，所以在这多个 c 文件编译时是不会出错的，但在**链接**时就会报错，说你多处**定义**了同一个变量



# 命名常量

格式：const int CARD_COUNT = 54;

枚举量:

```cpp
enum Color 
{ 
RED = 0xFF0000,
GREEN = 0x00FF00, 
BLUE = 0x0000FF
};

```

枚举类

```cpp
enum class Color 
{ 
RED = 0xFF0000,
GREEN = 0x00FF00, 
BLUE = 0x0000FF
};

```

> [!warning]
>
> **初始化**
> const对象定义后就不能被修改

> [!tip]
>
> 1. 把普通对象声明为const会改变它的**类型**。类型为const int的对象与类型为int的对象**完全不同**
> 2. 在文件作用域定义的普通非const对象默认为**extern**，而const对象默认为**非extern**，即const对象默认为文件的局部变量，要使const对象能够在其他的文件中访问，**必须显式地指定它为extern**
> 3. 在文件作用域定义的普通非const对象只能出现在某个源文件中，而const对象可以定义在头文件中，每个包含该头文件的源文件都有了自己的const对象，其名称和值都一样

##### 常量折叠和宏替换

常量折叠（constant folding）是编译器优化的一种技术，它在编译期间对常量表达式进行计算并用计算结果替换原来的表达式。常量折叠的主要目的是提高运行时性能，因为计算在编译时已经完成，运行时不需要再进行这些计算。

### 宏替换和符号维护

**宏替换**：
宏替换发生在预处理阶段，编译器在编译源代码之前会对所有的宏定义进行展开。这意味着宏定义的符号会在预处理阶段被替换成它们的实际内容，从而在之后的编译阶段这些符号就不再存在。例如：

```cpp
#define PI 3.14

double area = PI * radius * radius;
```

在预处理阶段，代码会变成：

```cpp
double area = 3.14 * radius * radius;
```

这里，`PI` 已经被替换成 `3.14`，之后的编译器优化阶段***再也看不到 `PI`*** 这个符号。因此，***编译器不再维护这个符号***。

**常量折叠**：
常量折叠发生在编译阶段，编译器可以识别出代码中的常量表达式并对其进行计算。例如：

```cpp
const double pi = 3.14;

double area = pi * radius * radius;
```

在编译阶段，编译器可以看到 `pi` 是一个常量，并且可以将表达式 `pi * radius * radius` 中的 `pi` 进行折叠计算。但是，即使经过常量折叠，`pi` 作为一个符号仍然存在于符号表中，编译器仍然会维护这个符号。因此，***常量折叠后的常量名不会消失***。

### 总结

- **宏替换**发生在预处理阶段，宏名在替换后不再存在于代码中，编译器在编译阶段无法看到这些符号。
- **常量折叠**发生在编译阶段，编译器在计算常量表达式时会保持常量名的存在，这些常量仍然在符号表中，因此编译器可以继续维护这些符号。

# 常指针

![image-20240605230057483](C:\Users\10164\AppData\Roaming\Typora\typora-user-images\image-20240605230057483.png)

# 字符串

![image-20240605230138718](C:\Users\10164\AppData\Roaming\Typora\typora-user-images\image-20240605230138718.png)

# 杂项

> [!warning]
>
> static仅定义一次!



# chapter5-函数

### 杂项

##### 异常(简单)

![image-20240606232731545](C:\Users\10164\AppData\Roaming\Typora\typora-user-images\image-20240606232731545.png)

##### 缺省参数

缺省参数不能作为区分标志，
且编译时匹配

### 函数的声明和定义

与变量必须先声明后使用一样，函数也必须在被调用之前先声明。
与变量的声明和定义一样，函数的声明也可以和函数的定义分离。
通常情况下，一个函数可以声明多次但只能定义一次(**链接性**决定的)。
函数应当在**头文件**中声明，并在**源文件**中定义：
   1.把函数声明放在头文件中，可以确保对于指定**函数其所有声明保持一致。**如果函数**接口**发生变化，则只要修改其唯一的**声明**即可；
   2.**定义函数的源文件应包含声明该函数的头文件**。这样可使编译器能够检查该函数的**定义和声明时是否一致**。特别地，如果函数定义和函数声明的形参列表一致，但返回类型不一致，编译器会发出警告或出错信息来指出这种差异。

### 连接性

链接性是指程序编译时，程序中的名字(标识符)在整个程序或单独编译单元中能否绑定到同一实体。

#### 内部链接性(静态链接性)

静态链接性也称为**内部链接性**，限定名字在一个编译单元内可见。

> [!note]
>
> 具有内部链接性(静态链接性)的：
>     1.所有的**声明**
>     2.**命名空间**(包括全局命名空间)中的**静态**自由函数、**静态**友元函数、**静态**变量的定义、!!**const常量定义**!!
>     3.**enum**定义
>     4.**inline**函数定义(包括自由函数和非自由函数)
>     5.**类**(class、struct、union)的定义

#### 外部链接性(全局链接性)

外部链接性也称为**全局链接性**，具有全局链接性的名字可以在不同编译单元声明并绑定到同一实体。

> [!note]
>
> 具有外部链接性的：
>     1.非inline函数。包括命名空间中**非静态函数**、**类成员函数**和**类静态成员函数**  //函数: 非静态, 类成员
>     2.类**静态成员变量**  //变量: 类静态
>     3.命名空间(不包括无名命名空间)中**非静态变量**  //变量: 非静态

> [!tip]
>
> the static things which are external:
>
> 类静态成员变量, 类静态成员函数

无链接性的名字具有局部作用域，如局部变量、函数形参等。
跨语言链接，不同编程语言对同一名字编译后得到的修饰名字可能不同，因此需要提供相应机制来实现。

> [!caution]
>
> 对于具有外部链接性的函数来说，这意味着在多文件程序中，只能**有一个**文件（该文件也可能是库文件）包含该函数的定义，但使用该函数的每个文件都应**包含其函数声明**。
>
> 对于具有内部链接性的静态函数来说，这意味着可以在其他文件中定义**同名**的函数，并且，在当前文件中静态函数将**覆盖外部**定义。
>
> 假设在程序的某个文件中调用一个函数，C++将到哪里去寻找该函数的定义呢？如果该文件中的函数声明指出该函数具有内部链接性，则编译器将只在该文件中查找函数定义；否则，编译器将在所有的程序文件中查找。如果找到两个定义，编译器将发出错误消息，因为每个外部函数只能有一个定义。如果在程序文件中没有找到，编译器将在库中搜索。这意味着如果定义了一个与库函数同名的函数，编译器将使用程序员定义的版本，而不是库函数。

> [!tip]
>
> 将调用函数的方式改为顺序执行方式以节省时间开销，这一过程叫做内联函数的扩展。因此，内联函数实际上是一种用空间换时间的方案。

### 函数声明与调用

> [!tip]
>
> 格式：[extern] [调用约定] <返回类型><函数名> (<参数表>) [const][异常说明]；

##### 为什么从*右到左*进行参数压栈？

   历史原因

##### 谁来负责清栈或恢复堆栈？

调用者负责：可处理**变参**和确定参数个数的函数；

被调用者负责：只能处理确定参数个数的函数；

##### 被调用函数的名字如何表示？

同一个项目中的函数名字表示，限定名不同即可区分；不同项目中的函数名字表示，需要区分；

### 调用协定

这种协议规定了该语言函数调用时的参数传送方式、参数是否可变和由谁来处理堆栈等问题. 约定有cdecl、stdcall、fastcall、pascal、thiscall等几种

##### cdecl(调用者)

函数参数按照从右到左的顺序入栈，并且由**调用函数者**负责把参数弹出栈以清理堆栈

##### stdcall

函数参数按照从右到左的顺序入栈，**没有显式定义**非成员函数的调用约定, 并且由***被调用的函数***负责在返回前清理传送参数的栈，函数参数个数固定

##### fastcall

用于对**性能**要求非常高的场合, 通常将函数的从**左边**开始的两个大小不大于4个字节的参数通过**寄存器**传递，其余的参数仍旧自右向左压栈传递，并且由***被调用的函数***负责在返回前清理传送参数的堆栈。

### 名字重整

编译器通常会在生成源程序的目标文件阶段，将其中具有存储性质的对象的名字按照某种既定规则进行改写

> 所谓的具有存储性质的对象，即左值对象

### 函数重载(奥里给)

> [!tip]
>
> 兼容性原则:
>
> 只要有一个变量可以使之重载, 便是合法重载. 重载函数不会满足所有变量的情况.

> [!warning]
>
> 函数参数的个数、类型、顺序、const修饰、**异常**等不完全相同
> 返回值类型不作为区分标志
> 缺省参数不作为区分标志
> **值类型**参数的const型与非const型不作为区分标志
> 引用和指针类型参数，**是否可以改变实参**，可作为区分标志

根据操作数的类型来区分不同的操作，并应用适当的操作，是编译器的责任，而不是程序员的事情. 通过省去为函数起名并记住函数名字的麻烦，函数重载简化了程序的实现，使程序更容易理解

```cpp
int Func();
int Func(int);
int Func(int,int);
int Func(int,int) const;  //只能是成员函数
int Func(int) throw( );
int Func(int) throw(int,MyE,YourE);
int Func(MyClass obj);
```

**函数重载和作用域**

重载函数应在同一个作用域中声明。如果局部地声明一个函数，则该函数将屏蔽而不是重载在外层作用域中声明的同名函数

例:

```c
     void print( const string& );
     void print( double );        //重载

     void foobar( int i )
     {
	     extern void print(int);  //隐藏print()      or  int print=0;
	     print(“Value”);            //错误
	     print(i);                        //正确
     }

```

##### 重载函数绑定

> [!note]
>
> **确定候选函数、选择*可行函数*、寻找最佳匹配.**

例:

```c++
     void f();
     void f(int);
     void f(int, int);
     void f(double, double = 3.14);
     f(5.6);  // calls void f(double, double)
     f(42, 2.56);  // error
     f(static_cast<double>(42), 2.56);  // calls f(double, double)
     f(42, static_cast<int>(2.56));     // calls f(int, int)

```

##### 参数表

函数的缺省参数既可以在函数声明也可以在函数定义中指定默认实参。但是，在一个文件中，只能为形参指定默认实参一次.

> [!tip]
>
> 应在**函数声明**中指定默认实参，并将该**声明放在合适的头文件**中。如果在函数定义的形参表中提供默认实参，那么**只有在包含该函数定义的源文件中调用该函数时，默认实参才是有效的**.

如果一个函数被声明多次并出现在不同的作用域内，则**允许**分别为它们指定不同的默认实参.

```cpp
int f(int a=6,float b=5.0,char c='.',int d=10);
int main( )
{
int f(int a=3,float b=2.0,char c='n',int d=20);    	cout<<f( )<<endl;      //f函数使用局部默认实参
return 0;
} 
```

##### 实参和形参的匹配

> [!note]
>
> 压栈顺序由调用约定确定
> 但计算顺序是不确定的

**错误的**例子

```cpp
int a =10;
f(++a,++a,++a);
func( MyF(a),YourF(a)+6 );
```

当一个函数有多个形参时，C++语言没有规定函数调用时实参的求值顺序，编译器根据对代码进行优化的需要自行规定对实参的求值顺序
在实参中注意不要使用带有副作用的运算符，此时可能产生二义性.

> [!note]
>
> 缺省参数的匹配
> 实参的类型转换

###### 缺省参数：

在**编译**时匹配，而不是运行时；
第一个带缺省值参数的右侧必须都有缺省值；

```cpp
void f(int,char=‘c’,int); //非法
void f(int,char=‘c’,int=9);//正确
```

###### 转换：

若不存在完全匹配的函数，尝试类型转换（每个参数只一次）。

```cpp
void f(int);
void f(double);
```

 实际调用：f(2.5f);

> [!note]
>
> 值传递
> 指针传递
> 数组的传递
> 引用传递

##### 数组传递

可将使用数组语法定义的形参看作指向数组**元素类型**的指针。上面的几种定义是等价的，形参类型都是 int*

```cpp
int a[3]={1,2,3};
```

编译器只会检查实参是不是指针、指针的类型和数组元素的类型是否匹配，而不会检查数组的长度

以下几个等价:

```cpp
void f(int[ ]);
void f(int a[ ]);
void f(int a[3]);
void f(int a[5]);
void f(int * a);
//二维
void fun(int array[5][10]);        //第一维的大小通常省略
void fun(int array[][10], int i);  //fun(int array[][]);是错误的 仅能省略第一维
void fun(int (*array)[10], int i);
void fun(int *array[5], int j);
void fun(int *array[], int i, int j);
void fun(int **array, int i, int j);
```

##### 引用传递

引用对实参的要求

> [!caution]
>
> 不允许传递一个**右值**或具有需要转换的类型的对象(类型不匹配的对象)
> 非const 引用形参只能与**完全同类型**的非const 对象关联
> 应该传入一个**有效**的对象

> [!tip]
>
> 为避免限制对函数的使用，应该将不修改相应实参的形参定义为 const 引用

### 返回类型

##### 值/指针

##### ![image-20240609181828199](C:\Users\10164\AppData\Roaming\Typora\typora-user-images\image-20240609181828199.png)

##### 引用

![image-20240609181922057](C:\Users\10164\AppData\Roaming\Typora\typora-user-images\image-20240609181922057.png)

返回引用的函数返回一个左值。因此，这样的函数可用于任何要求使用左值的地方.

![image-20240609181946883](C:\Users\10164\AppData\Roaming\Typora\typora-user-images\image-20240609181946883.png)

## 函数link数组

![image-20240609211831338](C:\Users\10164\AppData\Roaming\Typora\typora-user-images\image-20240609211831338.png)

理解 `int * (*T[5])(void);` 这种复杂的C++声明需要一步步分析。我们可以从内到外逐层解读每个部分的含义。为了更清晰地解释，我们可以遵循以下步骤：

### 步骤 1: 基本语法结构

从最内层开始，逐步解释并扩展：

1. **`T[5]`**: 这是一个数组声明。`T` 是一个包含 5 个元素的数组。
2. **`(*T[5])`**: 这表明数组 `T` 中的每个元素是一个**指针**。
3. **`(*T[5])(void)`**: 进一步表明，`T` 中每个指针指向的是一个**函数**，该函数没有**参数**（`void` 表示函数没有参数）。
4. **`int * (*T[5])(void)`**: 最外层表明，这些**函数**返回一个 `int` 类型的指针。

### 步骤 2: 分解和重组

让我们从里到外一步步解析 `int * (*T[5])(void);`：

1. **`T[5]`**: 声明 `T` 是一个包含 5 个元素的数组。
2. **`*T[5]`**: 数组中的每个元素是一个指针。
3. **`(*T[5])(void)`**: 每个指针指向一个接受 `void` 参数的函数。
4. **`int * (*T[5])(void)`**: 每个函数返回一个指向 `int` 类型的指针。

因此，`int * (*T[5])(void);` 声明了一个包含 5 个元素的数组 `T`，其中每个元素是一个指向函数的指针，这些函数不接受参数并返回一个指向 `int` 的指针。

### 更具体的解释

为了更好地理解这种声明，可以考虑以下具体的例子：

```cpp
int* func1(void) {
    static int x = 10;
    return &x;
}

int* func2(void) {
    static int y = 20;
    return &y;
}

int* func3(void) {
    static int z = 30;
    return &z;
}

int* func4(void) {
    static int w = 40;
    return &w;
}

int* func5(void) {
    static int v = 50;
    return &v;
}

int* (*T[5])(void) = { func1, func2, func3, func4, func5 };

int main() {
    for (int i = 0; i < 5; ++i) {
        int* result = T[i](); // 调用 T 数组中的函数
        std::cout << "Result from func" << i+1 << ": " << *result << std::endl;
    }
    return 0;
}
```

在这个例子中：

- 定义了5个函数 `func1` 到 `func5`，每个函数返回一个指向 `int` 的指针。
- 声明了一个数组 `T`，并将这5个函数的地址赋给数组 `T` 的每个元素。
- 在 `main` 函数中，通过调用 `T` 中的每个函数，打印返回的 `int` 值。

### 视觉化理解

如果用图表来表示 `int * (*T[5])(void);` 的结构，它可以如下图所示：

```sql
T:
+-----------+   +-----------+   +-----------+   +-----------+   +-----------+
| T[0]      |   | T[1]      |   | T[2]      |   | T[3]      |   | T[4]      |
| function* |   | function* |   | function* |   | function* |   | function* |
+-----|-----+   +-----|-----+   +-----|-----+   +-----|-----+   +-----|-----+
      |               |               |               |               |
      v               v               v               v               v
  +---|---+       +---|---+       +---|---+       +---|---+       +---|---+
  | func1 |       | func2 |       | func3 |       | func4 |       | func5 |
  +---|---+       +---|---+       +---|---+       +---|---+       +---|---+
      |               |               |               |               |
      v               v               v               v               v
  +---|---+       +---|---+       +---|---+       +---|---+       +---|---+
  | int*  |       | int*  |       | int*  |       | int*  |       | int*  |
  +-------+       +-------+       +-------+       +-------+       +-------+
```

### 小结

- **`T` 是一个指针数组**：`T` 是一个包含 5 个元素的数组。
- **每个元素是一个函数指针**：数组中的每个元素是一个指向函数的指针。
- **这些函数无参数并返回 `int` 指针**：每个函数都不接受参数，并返回一个指向 `int` 类型的指针。

理解这些复杂的声明，需要分解每个部分，逐步解析和组合，才能彻底理解其含义。
