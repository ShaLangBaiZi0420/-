# oop15-17

## 15-继承

拷贝、粘贴、修改
水平关系-普通关联、聚合、组合和依赖---黑盒复用
垂直关系-继承--白盒复用



黑盒复用是一种功能复用
改变被复用类（A）的具体实现，不会影响复用类（B、C）的实现
但要求被复用类具有良好的设计(行为的设计合理、独立)



白盒复用是一种实现复用或代码复用



### 派生类

派生类中的成员: 
派生类的构造、析构、拷贝、赋值函数
派生类中定义的成员函数、数据成员
基类中的所有成员**（除基类的构造、析构、拷贝、赋值函数)**



基类中的静态成员在整个继承层次中只有一个实例，通过基类或派生类都可以访问.



既然基类中private的成员在派生类中都是不可访问的，为什么派生类还要含有这些不可访问的基类数据成员和成员函数？

1. 数据隐藏与封装

2. 实现细节的隔离

3. 提供接口而非实现

4. 确保接口的一致性

5. 对象模型和内存布局



### 派生类的构造和析构

基类的构造、析构、拷贝、赋值不会被派生类自动继承

##### 派生类的构造函数：

构造顺序：先基类，再派生类
初始化列表中可以指定基类的构造函数或拷贝构造函数
多重继承时，基类按先后顺序构造

##### 派生类的析构函数：

先执行派生类的析构，再自动执行基类析构



对从基类继承过来的成员的初始化，派生类构造函数最好不要采用函数体内直接赋值的方式，而是通过初始化列表调用直接基类的适当的构造函数来间接初始化，绝不允许在初始化列表对其直接初始化或调用基类其他成员函数初始化
当基类中没有显式定义构造函数时，派生类可以不必显式定义构造函数，或者显式定义构造函数，但初始化列表可以省略对基类构造函数的调用
当基类中显式定义构造函数时，派生类也应该显式定义构造函数，并通过初始化列表调用直接基类的适当的构造函数来初始化从基类继承过来的成员

## NROO:

newdefine、redefine、overload、overwrite(hide)

### 派生类中的成员函数

派生类中的构造、析构、拷贝、赋值
(若无明确定义，则使用缺省的)
派生类中的静态函数
(派生类定义的+继承自基类的)
继承的基类函数
(派生类中明确定义的函数)



newdefine：派生类中新定义的函数(基类中无同名的函数)
redefine:      派生类中新定义的函数(基类中有同名、同原型的函数)
overload:     派生类中多个同名的重载函数
overwrite:    派生类中定义了某个函数，且基类中有同名的函数，则派生类的函数会将基类的同名函数隐藏（hide)掉。
override：若基类中的某个函数时虚的(带virtual关键字)，并在派生类中定义了相同原型的函数，称override

使用using : 略



## 继承方式的含义:

继承方式：class Derived：<继承方式> Base {  };
public： 表示”is a kind of ” ,“is a , ”like a ”的关系
private：表示”has-a”,”contain-a”, ”implement of ”的关系
protected：同private，同时便于在多层继承中保持这种关系



## 组合和继承的选择

组合:
具有”has-a”或”contain-a”的关系
子对象所属类的源代码，可有可无。
类间是水平关系，相比继承可减少类的层次。
继承：继承方式不同，目的不同
public继承：表示“is-a”的关系。
private：表示”has-a”,”contain-a”, ”implement of ”的关系，完全可换成组合。
protected：同private，同时便于在多层继承中保持这种关系

选择：
优先选择组合，而不是继承
在需要派生新的子类的情况下，才应采用公有继承。

## 16-类型转换

**保护和私有继承下(protected、private):**     从基类向派生类转换：
Base类和Derived类中的public互不相同，向下类型转换无实际意义(行为集不同，数据也不全)
若确实需要，可在Derived中定义构造函数

```cpp
Derived::Deived(const Base&);
```

或在Base类中定义类型转换函数

```cpp
Base::operator Derived();
```

**public继承方式下:**
此时的向上类型转换有意义
逻辑上，是类型的泛化或一般化
语言上，public行为集被窄化



指针型：安全的
引用型：安全的
对象型：安全的，但进行了对象裁剪。
结论:应尽可能使用指针或引用型向上类型转换。



向下类型

**public继承方式下向下类型转换:**
此时的向下类型转换有意义
但可能成功，也可能失败
只能在运行时确定(dynamic_cast)



### c++类型转换操作符

![image-20240629173010786](C:\Users\10164\AppData\Roaming\Typora\typora-user-images\image-20240629173010786.png)

格式：static_cast<T>(exp)

静态转换：用隐式和用户定义转换的组合在类型间转换。

等价于C语言中的强制类型转换 (T)exp



格式：const_cast<T>(exp)
常量转换：用于添加或移除表达式中的const或volatile约束
说明：其中 T 与exp的类型，除了const或volatile等修饰之外，必须一致



格式：reinterpret_cast<T>(exp)
重新解释：对表达式的类型做出重新解释，常用于重新解释函数

#### 指针类型转换

将一个指向某种类型的指针转换为另一种类型的指针：

```cpp
int num = 42;
void* ptr = &num;
int* intPtr = reinterpret_cast<int*>(ptr);
std::cout << *intPtr << std::endl; // 输出：42
```

在这个例子中，我们将一个 int* 转换成了 void*，然后使用 reinterpret_cast 将 void* 再转换回 int*。

#### 指针和整数之间的转换

将指针转换为整数或将整数转换为指针：

```cpp
int num = 42;
void* ptr = &num;
uintptr_t intPtrValue = reinterpret_cast<uintptr_t>(ptr);
void* newPtr = reinterpret_cast<void*>(intPtrValue);
std::cout << *reinterpret_cast<int*>(newPtr) << std::endl; // 输出：42
```

这里，我们将一个 void* 转换为一个 uintptr_t（通常是一个足够大的无符号整数类型，可以保存指针），然后又把这个整数转换回一个指针。



格式：dynamic_cast<T>(exp)
动态转换：
在运行时刻，尝试将exp转换成T类型。多用于public继承下，将父类类型转换成子类类型；
T只能为类的指针、类的引用、void *三种形式;
dynamic_cast要用到RTTI(运行时类型识别),通常各编译器都是通过虚拟表(VTable)来实现RTTI的，因此类中要有虚函数，才能使用.





## chapter17

草泥马继承



虚基类

缺点：    

要求B类及C类的作者，预知未来会被多重继承

类型的向上转换困难

存储格式:

![image-20240629194035393](C:\Users\10164\AppData\Roaming\Typora\typora-user-images\image-20240629194035393.png)

其他解决方案:

限定只能单继承
限定多个基类中，至多只能有一个基类有实例变量
避免了多重继承下数据成员名字冲突的问题
保留了多重继承的方便性